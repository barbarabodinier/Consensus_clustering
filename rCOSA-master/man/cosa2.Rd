% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cosa2.R
\name{cosa2}
\alias{cosa2}
\title{COSA 2 Dissimilarities}
\usage{
cosa2(
  X,
  lX = NULL,
  targ = NULL,
  targ2 = NULL,
  knear = sqrt(nrow(X)),
  xmiss = NULL,
  lambda = 0.2,
  qntls = c(0.05, 0.95),
  wtcomb = "each",
  relax = 0.1,
  conv = 1e-05,
  niter = 1,
  noit = 100,
  stand = 1,
  pwr = 1
)
}
\arguments{
\item{X}{input data.frame, or matrix object in numeric mode. COSA calculates the dissimilarities for the rows in X.}

\item{lX}{either an integer or a vector with as much elements as columns in \code{X}. This argument is ignored if \code{X} is a data.frame \cr
\cr.
Each element \code{lX[k]} represents a label for \code{X[,k]} as indicated below: \cr
0 => ignore \code{X[, k]}, \cr
\cr
\code{1} => \code{X[, k]} is a numeric attribute, no target value, \cr
\code{2} => \code{X[, k]} is a numeric attribute, single target value, \cr
\code{3} => \code{X[, k]} is a numeric attribute, dual target values, \cr
\code{4} => \code{X[, k]} is a categorical attribute, no target value, \cr
\code{5} => \code{X[, k]} is a categorical attribute, single target value, \cr
\code{6} => \code{X[, k]} is a categorical attribute, dual target values. \cr
\cr
If only an integer scalar is give for \code{lX} than it is assumed that the integer value is the label for all columns in \code{X}. \cr Target values are specified in the targ, targ2 or qntls arguments (see below)\cr}

\item{targ}{target values for computing targeted dissimilarities. The \code{targ[k]} is the target value for \code{X[,k]}. The value is ignored if \code{lX[k] = 0}, \code{1}, or \code{4}. \cr
        If \code{lX[k]=2} or \code{5}, then \code{targ[k]} contains the single target value. \cr
        If \code{lX[k]=3} or \code{6}, then \code{targ[k]} contains one of the two target values. \cr
\cr
        Special values: \cr

           \code{targ = "low"} => use the \code{qntls[1]} quantile of \code{X[,k]} as a single target value. \cr
           \code{targ = "high"} => use the \code{qntls[2]} quantile of \code{X[,k]} as a single target value.    \cr
           \code{targ = "high/low"} => use the \code{qntls[1]} and \code{qntls[2]} quantiles of \code{X[,k]} as dual target values (see \code{qntls} argument described below). \cr}

\item{targ2}{the second target value when computing dual targeted dissimilarities. The \code{targ2[j]}  = second target value for \code{X[,k]}. The value is ignored if \code{lX[k] = 0},\code{1},\code{2},\code{4},\code{5}, or when \code{targ = "low"},\code{"high"}, or \code{"high/low"}.
\cr}

\item{knear}{size of number of objects in the near-neighborhoods which is used to calculate attribute weights for each object. By default \code{knear = sqrt(nrow(X))}, which, inside the function, is truncated to an  integer.
\cr}

\item{xmiss}{numeric value for missings in the data, by default it is set to \code{NULL}. In case you have coded missings in the data differently by using a number then indicate that number in this argument. The coded value for missings must be larger than any data value on any input variable.
\cr}

\item{lambda}{multiple attribute clustering incentive parameter. By default, the regularization parameter lambda is set to equal \code{0.2}.
\cr}

\item{qntls}{quantiles used for calculating high and/or low targets (ignored if \code{lX[k] = 0},\code{1},\code{4} or \code{targ} is NOT set to \code{"low"}, \code{"high"}, or \code{"high/low"}). \cr
\cr
\code{qntls[1]} = data quantile on each attribute used for low target \cr
\code{qntls[2]} = data quantile on each attribute used for high target \cr
\cr
NOTE: The \code{lX} vector and/or the value of \code{xmiss} can be specified as attributes to the input data matrix before invoking cosa \cr
\code{attr(X,"lX")<-lX} \cr
\code{attr(X,"xmiss")<-xmiss} \cr
\cr
When present the attribute values will be used whenever the corresponding arguments are missing. Specifying an argument value overrides the corresponding attribute values if present. If the attribute and its corresponding argument are both missing, the default values above are used.
\cr}

\item{wtcomb}{by default is set to 'each', meaning that the maximum of the weights of object \code{X[i,]} and object \code{X[j,]} is choosen for each attribute \code{X[,k]}. One can also choose for the option 'whole', meaning that a whole weight vector is choosen of either object \code{i} or \code{j}, depending on which of the two vectors give the maximum weighted dissimilarity between object \code{i} and \code{j}.
\cr}

\item{relax}{the number with which the homotopy parameter eta should be incremented at each outer iteration (for more info see noit)
\cr}

\item{conv}{the convergence treshold that can reduce the maximum number of inner iterations.
\cr}

\item{niter}{the maximum number of inner iterations to stabilize the weights and dissimilarties given the homotopy parameter
\cr}

\item{noit}{the number of outer iterations ( make sure relax > 0 ) to transfer from the inverse exponential distance more closely to the sum of the weighted dissimilarities, obtained when a large enough number of outer iterations is chosen. Starting with the initial value of the homotopy parameter (equal to lambda) and using increments determined by relax one can calculate at what value the homotopy parameter will end.
\cr}

\item{stand}{equals \code{0} for no standardisation, \code{1} for robust standard scaling of the data, and \code{2} for standard scaling of the data. The defeault equals \code{1}.
\cr}

\item{pwr}{\code{1} for L_1 norm attribute distances, and \code{2} for L_2 norm attribute distances. The default equals \code{1}. This argument is ignored for categorical/ordinal attributes.}
}
\value{
This function outputs a list that has as the first element the call, as the second element the dissimilarity matrix \code{out$D} of class dist, and by default also the weights of class matrix, and, if \code{crit} is set to \code{TRUE}, the values of the tuning parameters are also given in the output.
}
\description{
This function outputs a dissimilarity matrix of dissimilarities between the rows a data matrix computed by the COSA 2 algorithm. It is assumed that users are familiar with the COSA paper(s) or the vignette that comes with the rCOSA package, see references below.
}
\note{
The output dissimilarity matrix can be used as input to most dissimilarity based clustering procedures in R in the same manner as the output of the procedure \code{\link[stats]{dist}}.
}
\examples{
data(ApoE3)
rslt_dflt_cosa2 <- cosa2(X = ApoE3)
# The weight of object 1 on attribute 1 in the NxP weight matrix W
rslt_dflt_cosa2$W[1, 1]
# COSA procedure for dual targeted dissimilarities:
rslt_duotrg_cosa <- cosa2(X = iris[, 1:4], lX = rep(3, ncol(iris[, 1:4])), targ = 'high/low')


}
\references{
Friedman, J. H. and Meulman, J. J. (2004). Clustering objects on subsets of attributes. \cr URL: \url{http://www-stat.stanford.edu/~jhf/ftp/cosa.pdf}
Kampert, M.M., Meulman J.J., Friedman J.H. (2017). rCOSA: A Software Package for Clustering Objects on Subsets of Attributes \cr URL: \url{https://link.springer.com/article/10.1007/s00357-017-9240-z}
}
\seealso{
\code{\link[rCOSA]{hierclust}}, \code{\link[rCOSA]{getclust}}, and \code{\link[rCOSA]{smacof}}.
}
\author{
Maarten M.D. Kampert, Jacqueline J. Meulman, and Jerome H. Friedman. \cr Correspondence: \email{mkampert@math.leidenuniv.nl}
}
